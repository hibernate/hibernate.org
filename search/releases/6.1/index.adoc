:awestruct-layout: project-releases-series
:awestruct-project: search
:awestruct-series_version: "6.1"
:page-interpolate: true
:hsearch-doc-url-prefix: #{reference_doc(site.projects[page.project], series(page, page.series_version)).html_url}
:hsearch-jira-url-prefix: https://hibernate.atlassian.net/browse

=== Dependency upgrades

[[orm-version]]
Hibernate ORM (link:{hsearch-jira-url-prefix}/HSEARCH-4279[HSEARCH-4279])::
Hibernate Search 6.1 relies on Hibernate ORM 5.5.

[[lucene-version]]Lucene (link:{hsearch-jira-url-prefix}/HSEARCH-4169[HSEARCH-4169])::
The Lucene backend now uses Lucene 8.8.

[[elasticsearch-version]]
Elasticsearch (link:{hsearch-jira-url-prefix}/HSEARCH-4235[HSEARCH-4235])::
The Elasticsearch backend now works with Elasticsearch 5.6, 6.8 or 7.13.

[[async-indexing]]
=== Asynchronous, distributed automatic indexing

While it's technically possible to use Hibernate Search 6.0 and Elasticsearch in distributed applications,
it suffers from a few link:{hsearch-doc-url-prefix}#architecture-examples-no-coordination-elasticsearch-pros-and-cons[limitations].

The main goal of Hibernate Search 6.1 is to eliminate these limitations
by introducing coordination between application nodes
to implement asynchronous, distributed automatic indexing.

In link:{hsearch-jira-url-prefix}/HSEARCH-3280[HSEARCH-3280],
we introduce the very first coordination strategy;
more should follow in later versions of Hibernate Search (e.g. link:{hsearch-jira-url-prefix}/HSEARCH-3513[HSEARCH-3513]).
This strategy creates a table in the database to push entity change events to,
and relies on a background processor to consume these events and perform automatic indexing.

image::hsearch-architecture-database-polling-elasticsearch.svg[Clustered architecture with database polling and Elasticsearch backend,align="center",width="100%"]

Beside eliminating the limitations mentioned above,
another advantage of this strategy is that
Hibernate Search will no longer trigger lazy-loading or build documents in application threads,
which can improve the responsiveness of applications (less work to do on commit).

To learn more about an architecture based on `database-polling` coordination,
head to link:{hsearch-doc-url-prefix}#architecture-examples-database-polling-elasticsearch[this section of the documentation].
You can also get a quick overview of several architectures link:{hsearch-doc-url-prefix}#architecture-examples-overview[here].

To jump right in and try the strategy in a single-node application,
just set the following property
(you will also need to link:{hsearch-doc-url-prefix}#coordination-database-polling-schema[add tables to your database schema]):

[source]
----
hibernate.search.coordination.strategy = database-polling
----

For multi-node applications, a bit more configuration may be necessary.
Head to link:{hsearch-doc-url-prefix}#coordination-database-polling[this section of the documentation]
for more information on how to configure coordination.

[NOTE]
====
The `database-polling` coordination strategy can perfectly well be used with a Lucene backend.

You will still be limited to a single application node,
but you will benefit from all the other advantages (data safety, increased application responsiveness, ...).
====

[[opensearch]]
=== OpenSearch compatibility

Since link:{hsearch-jira-url-prefix}/HSEARCH-4212[HSEARCH-4212],
Hibernate Search is also compatible with https://opensearch.org/[OpenSearch] 1.0,
the Apache 2.0 licensed fork of Elasticsearch,
and regularly tested against it.

To use Hibernate Search with OpenSearch,
use the same Maven artifacts, configuration and API
that you would have used with Elasticsearch.

The only (minor) difference between using Elasticsearch and OpenSearch
is if you link:{hsearch-doc-url-prefix}#backend-elasticsearch-configuration-version[configure the Elasticsearch version explicitly]:
with OpenSearch, you need to prefix the version with `opensearch:`, e.g. `opensearch:1.0`.

[[search-dsl]]
=== Search DSL improvements

New link:{hsearch-doc-url-prefix}#search-dsl-predicate-terms[`terms` predicate] (link:{hsearch-jira-url-prefix}/HSEARCH-2589[HSEARCH-2589])::
Matches documents for which a given field contains some terms, any or all of them.
+
Useful for enum-typed fields, in particular.
+
[source, JAVA, indent=0]
----
List<Book> hits = searchSession.search( Book.class )
        .where( f -> f.terms().field( "genre" )
                .matchingAny( Genre.CRIME_FICTION, Genre.SCIENCE_FICTION ) )
        .fetchHits( 20 );
----
New link:{hsearch-doc-url-prefix}#search-dsl-predicate-regexp[`regexp` predicate] (link:{hsearch-jira-url-prefix}/HSEARCH-3884[HSEARCH-3884])::
Matches documents for which a given field contains a word matching the given regular expression.
+
[source, JAVA, indent=0]
----
List<Book> hits = searchSession.search( Book.class )
        .where( f -> f.regexp().field( "description" )
                .matching( "r.*t" ) )
        .fetchHits( 20 );
----
New link:{hsearch-doc-url-prefix}#_id_return_identifiers_of_matched_entities[`id` projection] (link:{hsearch-jira-url-prefix}/HSEARCH-4142[HSEARCH-4142])::
Returns the identifier of the matched entity.
+
[source, JAVA, indent=0]
----
List<Integer> hits = searchSession.search( Book.class )
        .select( f -> f.id( Integer.class ) )
        .where( f -> f.matchAll() )
        .fetchHits( 20 );
----
link:{hsearch-doc-url-prefix}#search-dsl-sort-common-missing[Configurable `.missing()` behavior] for `distance` sort (link:{hsearch-jira-url-prefix}/HSEARCH-3863[HSEARCH-3863])::
Distance sorts now allow
specifying the behavior when encountering documents with missing values
(though only `.missing().first()`/`.missing().last()` are supported with Elasticsearch).
+
[source, JAVA, indent=0]
----
GeoPoint center = GeoPoint.of( 47.506060, 2.473916 );
List<Author> hits = searchSession.search( Author.class )
        .where( f -> f.matchAll() )
        .sort( f -> f.distance( "placeOfBirth", center )
                .missing().first() )
        .fetchHits( 20 );
----
link:{hsearch-doc-url-prefix}#search-dsl-paths-relative[Relative field paths] (link:{hsearch-jira-url-prefix}/HSEARCH-4245[HSEARCH-4245])::
The Search DSL now allows creating factories (`SearchPredicateFactory`, etc.)
that accept relative field paths.
+
This is mostly useful if you pass factories to reusable methods.
+
[source, JAVA, indent=0]
----
List<Book> hits = searchSession.search( Book.class )
        .where( f -> f.bool()
                .should( f.nested().objectField( "writers" )
                        .nest( matchFirstAndLastName(
                                f.withRoot( "writers" ),
                                "bob", "kane" ) ) )
                .should( f.nested().objectField( "artists" )
                        .nest( matchFirstAndLastName(
                                f.withRoot( "artists" ),
                                "bill", "finger" ) ) ) )
        .fetchHits( 20 );

private SearchPredicate matchFirstAndLastName(SearchPredicateFactory f,
        String firstName, String lastName) {
    return f.bool()
            .must( f.match().field( "firstName" )
                    .matching( firstName ) )
            .must( f.match().field( "lastName" )
                    .matching( lastName ) )
            .toPredicate();
}
----

[[mass-indexing-filter]]
=== Conditional mass indexing

link:{hsearch-jira-url-prefix}/HSEARCH-499[HSEARCH-499] introduces the ability
to link:{hsearch-doc-url-prefix}#mapper-orm-indexing-massindexer-conditional[apply the mass indexer to a subset of your entities],
based on an HQL/JPQL "where" clause.

[source, JAVA, indent=0]
----
SearchSession searchSession = Search.session( entityManager );
MassIndexer massIndexer = searchSession.massIndexer();
massIndexer.type( Book.class ).reindexOnly( "e.publicationYear <= 2100" );
massIndexer.type( Author.class ).reindexOnly( "e.birthDate < :birthDate" )
        .param( "birthDate", LocalDate.ofYearDay( 2100, 77 ) );
massIndexer.startAndWait();
----

[[named-predicates]]
=== Named predicates

link:{hsearch-jira-url-prefix}/HSEARCH-3325[HSEARCH-3325] adds link:{hsearch-doc-url-prefix}#mapper-orm-bridge-named-predicate[named predicates],
a way to define the search logic as part of a custom binder/bridge.

This is, in a way, the comeback of the
https://docs.jboss.org/hibernate/search/5.11/reference/en-US/html_single/#query-filter-fulltext["full-text filters" of Hibernate Search 5].

[[elasticsearch-custom-index-settings]]
=== Custom ES index settings

Since link:{hsearch-jira-url-prefix}/HSEARCH-3934[HSEARCH-3934],
you can link:{hsearch-doc-url-prefix}#_custom_index_settings[provide Hibernate Search with JSON files containing the desired settings of your indexes],
and Hibernate Search will automatically push these settings
when it creates/updates the indexes.

[source]
----
# To configure the defaults for all indexes:
hibernate.search.backend.schema_management.settings_file = custom/index-settings.json
# To configure a specific index:
hibernate.search.backend.indexes.<index name>.schema_management.settings_file = custom/index-settings.json
----

[[lucene-reader]]
=== Access to Lucene's `IndexReader`

Thanks to link:{hsearch-jira-url-prefix}/HSEARCH-4065[HSEARCH-4065],
you can now link:{hsearch-doc-url-prefix}#_retrieving_a_lucene_indexreader[retrieve an `IndexReader`]
when using the Lucene backend:

[source, JAVA, indent=0]
----
SearchMapping mapping = Search.mapping( entityManagerFactory );
LuceneIndexScope indexScope = mapping
        .scope( Book.class ).extension( LuceneExtension.get() );
try ( IndexReader indexReader = indexScope.openIndexReader() ) {
    // work with the low-level index reader:
    numDocs = indexReader.numDocs();
}
----

While generally not necessary, this can be useful for advanced, low-level operations.

[[lucene-caching]]
=== Lucene low-level hit caching

Since link:{hsearch-jira-url-prefix}/HSEARCH-3880[HSEARCH-3880],
Hibernate Search allows
link:{hsearch-doc-url-prefix}#backend-lucene-search-caching[configuring the `QueryCache` and `QueryCachingPolicy`]
in the Lucene backend,
adding one more performance tweak for advanced Lucene users.

